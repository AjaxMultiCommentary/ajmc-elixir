<!-- livebook:{"file_entries":[{"name":"3467O2_tess_retrained.json","type":"attachment"}]} -->

# Creating a TEI XML Version from Scratch

## Section

```elixir
alias TextServer.Collections
alias TextServer.Languages
alias TextServer.TextGroups
alias TextServer.Works
alias TextServer.Versions
```

```elixir
{:ok, collection} =
  Collections.find_or_create_collection(%{
    repository: "https://github.com/gregorycrane/Wolf1807",
    urn: "urn:cts:greekLit",
    title: "Towards a Smart App. Crit.: Sophocles' Ajax"
  })
```

```elixir
{:ok, text_group} =
  TextGroups.find_or_create_text_group(%{
    title: "Sophocles",
    urn: "urn:cts:greekLit:tlg0011",
    collection_id: collection.id
  })
```

```elixir
{:ok, work} =
  Works.find_or_create_work(%{
    description: "",
    english_title: "Ajax",
    original_title: "Αἶας",
    urn: "urn:cts:greekLit:tlg0011.tlg003",
    text_group_id: text_group.id
  })
```

```elixir
language = Languages.find_or_create_language(%{slug: "grc", title: "Greek"})
```

```elixir
xml = File.read!("./priv/static/xml/lloyd-jones1994/tlg0011.tlg003.ajmc-lj.xml")
```

```elixir
{:ok, version} =
  Versions.find_or_create_version(%{
    description: "edited by Hugh Lloyd-Jones",
    filename: "lloyd-jones1994/tlg0011.tlg003.ajmc-lj.xml",
    filemd5hash: :crypto.hash(:md5, xml) |> Base.encode16(case: :lower),
    label: "Sophocles' <i>Ajax</i>",
    language_id: language.id,
    urn: "urn:cts:greekLit:tlg0011.tlg003.ajmc-lj",
    version_type: :edition,
    work_id: work.id
  })

version = TextServer.Repo.preload(version, :xml_document)

if is_nil(version.xml_document) do
  Versions.create_xml_document!(version, %{document: xml})
end
```

## XML Spelunking with DataSchema

```elixir
version = TextServer.Versions.get_version!(1) |> TextServer.Repo.preload(:xml_document)
{:ok, xml} = TextServer.Versions.XmlDocuments.get_text_body(version.xml_document)

{:ok, lloyd_jones_body} = DataSchema.to_struct(version.xml_document, DataSchemas.Version)

%{word_count: _word_count, lines: lines} =
  lloyd_jones_body.body.lines
  |> Enum.reduce(%{word_count: 0, lines: []}, fn line, acc ->
    text = line.text |> String.trim()
    word_count = acc.word_count

    words =
      Regex.split(~r/[[:space:]]+/, text)
      |> Enum.with_index()
      |> Enum.map(fn {word, index} ->
        offset =
          case String.split(text, word, parts: 2) do
            [left, _] -> String.length(left)
            [_] -> nil
          end

        %{
          xml_id: "word_index_#{word_count + index}",
          offset: offset,
          text: word
        }
      end)

    new_line = %{elements: line.elements, location: [line.n], text: text, words: words}

    %{word_count: word_count + length(words), lines: [new_line | acc.lines]}
  end)

lines = Enum.reverse(lines)
```

```elixir
alias TextServer.ElementTypes
alias TextServer.TextElements
alias TextServer.TextNodes

lines
|> Enum.each(fn line ->
  {:ok, text_node} =
    TextNodes.find_or_create_text_node(%{
      location: line.location,
      text: line.text,
      urn: "#{version.urn}:#{Enum.at(line.location, 0)}",
      version_id: version.id
    })

  line.elements
  |> Enum.each(fn element ->
    {:ok, element_type} = ElementTypes.find_or_create_element_type(%{name: element.name})

    {:ok, text_element} =
      %{
        attributes: Map.new(element.attributes),
        end_offset: element.end_offset,
        element_type_id: element_type.id,
        end_text_node_id: text_node.id,
        start_offset: element.start_offset,
        start_text_node_id: text_node.id
      }
      |> TextElements.find_or_create_text_element()
  end)
end)
```

## Schematizing AjMC Canonical JSON

```elixir
path =
  "/Users/pletcher/code/ajmc/ajmc-multicommentary/priv/static/json/3467O2_tess_retrained.json"

s = File.read!(path)
json = Jason.decode!(s)

{:ok, data} = DataSchema.to_struct(json, DataSchemas.AjmcCanonicalCommentary)
```

```elixir
children = json |> Map.get("children")
lemmas = children |> Map.get("lemmas")
words = children |> Map.get("words")
regions = children |> Map.get("regions")

# region_types = regions |> Enum.map(& Map.get(&1, "region_type")) |> Enum.into(MapSet.new())

commentary =
  regions
  |> Enum.filter(&(Map.get(&1, "region_type") == "commentary"))
  |> Enum.map(fn comment ->
    word_range = Map.get(comment, "word_range")

    ws =
      words
      |> Enum.slice(Range.new(Enum.at(word_range, 0), Enum.at(word_range, 1)))
      |> Enum.map(&Map.get(&1, "text"))
      |> Enum.join(" ")

    Map.put(comment, :words, ws)
  end)
```

```elixir
alias TextServer.Commentaries
alias TextServer.CommentaryLemmas

{:ok, commentary} =
  Commentaries.upsert_canonical_commentary(%{
    pid: data.id,
    filename: "3467O2_tess_retrained.json",
    version_id: version.id
  })

# |> Enum.each(fn lemma ->
#   attrs = Map.from_struct(lemma) |> Map.put(:canonical_commentary_id, commentary.id)
#   CommentaryLemmas.upsert_commentary_lemma(attrs)

#   IO.inspect(lemma)
# end)
```
