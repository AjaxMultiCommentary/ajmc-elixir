<!-- livebook:{"file_entries":[{"name":"3467O2_tess_retrained.json","type":"attachment"}]} -->

# Creating a TEI XML Version from Scratch

## Section

```elixir
alias TextServer.Collections
alias TextServer.Languages
alias TextServer.TextGroups
alias TextServer.Works
alias TextServer.Versions
```

```elixir
{:ok, collection} =
  Collections.find_or_create_collection(%{
    repository: "https://github.com/gregorycrane/Wolf1807",
    urn: "urn:cts:greekLit",
    title: "Towards a Smart App. Crit.: Sophocles' Ajax"
  })
```

```elixir
{:ok, text_group} =
  TextGroups.find_or_create_text_group(%{
    title: "Sophocles",
    urn: "urn:cts:greekLit:tlg0011",
    collection_id: collection.id
  })
```

```elixir
{:ok, work} =
  Works.find_or_create_work(%{
    description: "",
    english_title: "Ajax",
    original_title: "Αἶας",
    urn: "urn:cts:greekLit:tlg0011.tlg003",
    text_group_id: text_group.id
  })
```

```elixir
language = Languages.find_or_create_language(%{slug: "grc", title: "Greek"})
```

```elixir
xml = File.read!("./priv/static/xml/lloyd-jones1994/urn:cts:greekLit:tlg0011.tlg003.ajmc-lj.xml")
```

```elixir
{:ok, version} =
  Versions.find_or_create_version(%{
    description: "edited by Hugh Lloyd-Jones",
    filename: "lloyd-jones1994/urn:cts:greekLit:tlg0011.tlg003.ajmc-lj.xml",
    filemd5hash: :crypto.hash(:md5, xml) |> Base.encode16(case: :lower),
    label: "Sophocles' <i>Ajax</i>",
    language_id: language.id,
    urn: "urn:cts:greekLit:tlg0011.tlg003.ajmc-lj",
    version_type: :edition,
    work_id: work.id
  })

version = TextServer.Repo.preload(version, :xml_document)

if is_nil(version.xml_document) do
  Versions.create_xml_document!(version, %{document: xml})
end
```

## XML Spelunking with DataSchema

```elixir
version = TextServer.Versions.get_version!(1) |> TextServer.Repo.preload(:xml_document)
{:ok, xml} = TextServer.Versions.XmlDocuments.get_text_body(version.xml_document)

{:ok, lloyd_jones_body} = DataSchema.to_struct(version.xml_document, DataSchemas.Version)

lines = lloyd_jones_body.body.lines

line_map = Map.new(lines, fn line -> {line.n, line} end)
```

## Schematizing AjMC Canonical JSON

```elixir
path =
  "/Users/pletcher/code/ajmc/ajmc-multicommentary/priv/static/json/3467O2_tess_retrained.json"

s = File.read!(path)
json = Jason.decode!(s)

{:ok, data} = DataSchema.to_struct(json, DataSchemas.AjmcCanonicalCommentary)
```

```elixir
alias TextServer.Commentaries
alias TextServer.CommentaryLemmas

{:ok, commentary} =
  Commentaries.upsert_canonical_commentary(%{
    pid: data.id,
    filename: "3467O2_tess_retrained.json",
    version_id: version.id
  })

data.lemmas
|> Enum.each(fn lemma ->
  attrs = Map.from_struct(lemma) |> Map.put(:canonical_commentary_id, commentary.id)
  CommentaryLemmas.upsert_commentary_lemma(attrs)

  IO.inspect(lemma)
end)
```
