# Creating a TEI XML Version from Scratch

## Section

```elixir
alias TextServer.Collections
alias TextServer.Languages
alias TextServer.TextGroups
alias TextServer.Works
alias TextServer.Versions
```

```elixir
{:ok, collection} =
  Collections.find_or_create_collection(%{
    repository: "https://github.com/gregorycrane/Wolf1807",
    urn: "urn:cts:greekLit",
    title: "Towards a Smart App. Crit.: Sophocles' Ajax"
  })
```

```elixir
{:ok, text_group} =
  TextGroups.find_or_create_text_group(%{
    title: "Sophocles",
    urn: "urn:cts:greekLit:tlg0011",
    collection_id: collection.id
  })
```

```elixir
{:ok, work} =
  Works.find_or_create_work(%{
    description: "",
    english_title: "Ajax",
    original_title: "Αἶας",
    urn: "urn:cts:greekLit:tlg0011.tlg003",
    text_group_id: text_group.id
  })
```

```elixir
{:ok, language} = Languages.find_or_create_language(%{slug: "grc", title: "Greek"})
```

```elixir
Application.ensure_all_started(:inets)
:ssl.start()

{:ok, resp} =
  :httpc.request(
    :get,
    {~c"https://raw.githubusercontent.com/gregorycrane/Wolf1807/master/ajax-2019/ajax-lj.xml",
     []},
    [],
    body_format: :binary
  )

{{_, 200, ~c"OK"}, _headers, body} = resp

xml = String.trim(body)
```

```elixir
{:ok, version} =
  Versions.find_or_create_version(%{
    description: "edited by Hugh Lloyd-Jones",
    filename: "Wolf1807/ajax-2019/ajax-lj.xml",
    filemd5hash: :crypto.hash(:md5, xml) |> Base.encode16(case: :lower),
    label: "Sophocles' <i>Ajax</i>",
    language_id: language.id,
    urn: "urn:cts:greekLit:tlg0011.tlg003.lloyd-jones1994",
    version_type: :edition,
    work_id: work.id
  })

version = TextServer.Repo.preload(version, :xml_document)

if is_nil(version.xml_document) do
  Versions.create_xml_document!(version, %{document: xml})
end
```

## XML Spelunking with DataSchema

```elixir
defmodule DataSchemas.Version do
  import DataSchema, only: [data_schema: 1]

  @data_accessor DataSchemas.XPathAccessor
  data_schema(has_one: {:body, "/TEI/text/body", DataSchemas.Version.Body})
end

defmodule DataSchemas.Version.Body do
  import DataSchema, only: [data_schema: 1]

  @data_accessor DataSchemas.XPathAccessor
  data_schema(
    has_many: {:notes, "/note", DataSchemas.Version.Body.Note},
    has_many: {:speakers, "./sp", DataSchemas.Version.Body.Speaker}
  )
end

defmodule DataSchemas.Version.Body.Note do
  import DataSchema, only: [data_schema: 1]

  @data_accessor DataSchemas.XPathAccessor
  data_schema(
    field: {:n, "./@n", &{:ok, &1}},
    field: {:text, "./text", &{:ok, &1}}
  )
end

defmodule DataSchemas.Version.Body.Speaker do
  import DataSchema, only: [data_schema: 1]

  @data_accessor DataSchemas.XPathAccessor
  data_schema(
    field: {:name, "./speaker/text()", &{:ok, &1}},
    has_many: {:lines, "./l", DataSchemas.Version.Body.Speaker.Line}
  )
end

defmodule DataSchemas.Version.Body.Speaker.Line do
  import DataSchema, only: [data_schema: 1]

  @data_accessor DataSchemas.XPathAccessor
  data_schema(
    field: {:n, "./@n", &{:ok, &1}},
    field: {:text, "./text()", &{:ok, &1}}
  )
end
```

```elixir
version = TextServer.Versions.get_version!(1) |> TextServer.Repo.preload(:xml_document)
xml = TextServer.Versions.XmlDocuments.get_text_body(version.xml_document)
```
